# 内核链表踩踏-前序节点


## 删除节点原理

```
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
}
```

* __list_del改变该节点前驱节点的后继结点和后继结点的前驱节点。
* 设置该节点的前驱节点和后继结点指向LIST_POSITION1和LIST_POSITION2两个特殊值，
  因为此节点只是从链表中删除，此节点所占用的内存空间并没有释放。
* 所以这样设置是为了保证不在链表中的节点项不可访问，对LIST_POSITION1和LIST_POSITION2的访问将引起页故障panic。





## 参考

* <https://www.cnblogs.com/wangzahngjun/p/5556448.html>
